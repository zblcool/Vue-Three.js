<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script type="text/javascript" src="rhill-voronoi-core.min.js"></script>
    <title>Document</title>
</head>

<body>
    <div id="container"></div>
    <canvas id="voronoiCanvas" width="800" height="600"></canvas>
</body>

<script id="script" type="text/javascript">
    // -->
</script>
<script type="module">
    import * as THREE from '../three.js/build/three.module.js';
    import {
        OrbitControls
    } from "../node_modules/three/examples/jsm/controls/OrbitControls.js";
    import {
        Delaunay
    } from "https://cdn.skypack.dev/d3-delaunay@6";
    import Stats from '../three.js/examples/jsm/libs/stats.module.js';

    let container, stats;

    let camera, scene, renderer;
    var texture;
    let pointsMesh;
    var colorArray = [];
    var colorAdded = false;
    var VoronoiDemo = {
        voronoi: new Voronoi(),
        diagram: null,
        margin: 0.1,
        canvas: null,
        bbox: {
            xl: 0,
            xr: 800,
            yt: 0,
            yb: 600
        },
        sites: [],
        timeoutDelay: 100,


    };
    init();
    animate();



    function init() {

        VoronoiDemo.canvas = document.createElement('canvas')
        randomSites(100, true);


        container = document.getElementById('container');

        //

        camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 5, 3500);
        camera.position.z = 250;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.Fog(0x050505, 2000, 3500);

        //

        const particles = 500000;

        const geometry = new THREE.PlaneGeometry(100, 100);

        const positions = [];
        const colors = [];
        const vertices = [];

        const color = new THREE.Color();

        const n = 1000,
            n2 = n / 2; // particles spread in the cube

        // for ( let i = 0; i < particles; i ++ ) {

        // 	// positions

        // 	const x = Math.random() * n - n2;
        // 	const y = Math.random() * n - n2;
        // 	const z = 0;

        // 	positions.push( x, y, z );

        // 	// colors

        // 	const vx = ( x / n ) + 0.5;
        // 	const vy = ( y / n ) + 0.5;
        // 	const vz = ( z / n ) + 0.5;

        // 	color.setRGB( vx, vy, vz );

        // 	colors.push( color.r, color.g, color.b );

        // }
        // geometry =  new THREE.PlaneGeometry( 1, 1 );
        // pointsMesh = new THREE.Points(geometry, material);
        var ctx = VoronoiDemo.canvas.getContext('2d');
        ctx.canvas.width = 512;
        ctx.canvas.height = 512;
        ctx.fillStyle = '#FFF';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        texture = new THREE.CanvasTexture(ctx.canvas);
        const material = new THREE.MeshBasicMaterial({
            map: texture,
            side: THREE.DoubleSide
        });
        const planeCavas = new THREE.Mesh(geometry, material)
        scene.add(planeCavas);

        //












        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        container.appendChild(renderer.domElement);

        //
        const controls = new OrbitControls(
            camera,
            renderer.domElement
        );
        controls.minDistance = 1;
        controls.maxDistance = 1000;
        controls.update();


        stats = new Stats();
        container.appendChild(stats.dom);

        //

        window.addEventListener('resize', onWindowResize);

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

    }

    //

    function clearSites() {
        VoronoiDemo.compute([]);
    }

    function randomSites(n, clear) {

        var sites = [];
        if (!clear) {
            sites = VoronoiDemo.sites.slice(0);
        }
        // create vertices
        var xmargin = VoronoiDemo.canvas.width * VoronoiDemo.margin,
            ymargin = VoronoiDemo.canvas.height * VoronoiDemo.margin,
            xo = xmargin,
            dx = VoronoiDemo.canvas.width - xmargin * 2,
            yo = ymargin,
            dy = VoronoiDemo.canvas.height - ymargin * 2;
        for (var i = 0; i < n; i++) {
            sites.push({
                x: self.Math.round((xo + self.Math.random() * dx) * 10) / 10,
                y: self.Math.round((yo + self.Math.random() * dy) * 10) / 10
            });
        }
        compute(sites);
        // relax sites
        if (VoronoiDemo.timeout) {
            clearTimeout(VoronoiDemo.timeout)
            VoronoiDemo.timeout = null;
        }
        var me = VoronoiDemo;
        VoronoiDemo.timeout = setTimeout(function () {
            relaxSites();
        }, VoronoiDemo.timeoutDelay);
    }

    function relaxSites() {
        if (!VoronoiDemo.diagram) {
            return;
        }
        var cells = VoronoiDemo.diagram.cells,
            iCell = cells.length,
            cell,
            site, sites = [],
            again = false,
            rn, dist;
        var p = 1 / iCell * 0.1;
        while (iCell--) {
            cell = cells[iCell];
            rn = Math.random();
            // probability of apoptosis
            if (rn < p) {
                continue;
            }
            site = cellCentroid(cell);
            dist = distance(site, cell.site);
            again = again || dist > 1;
            // don't relax too fast
            if (dist > 2) {
                site.x = (site.x + cell.site.x) / 2;
                site.y = (site.y + cell.site.y) / 2;
            }
            // probability of mytosis
            if (rn > (1 - p)) {
                dist /= 2;
                sites.push({
                    x: site.x + (site.x - cell.site.x) / dist,
                    y: site.y + (site.y - cell.site.y) / dist,
                });
            }
            sites.push(site);
        }
        compute(sites);
        if (again) {
            var me = VoronoiDemo;
            VoronoiDemo.timeout = setTimeout(function () {
                relaxSites();
            }, VoronoiDemo.timeoutDelay);
        }
    }

    function distance(a, b) {
        var dx = a.x - b.x,
            dy = a.y - b.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function cellArea(cell) {
        var area = 0,
            halfedges = cell.halfedges,
            iHalfedge = halfedges.length,
            halfedge,
            p1, p2;
        while (iHalfedge--) {
            halfedge = halfedges[iHalfedge];
            p1 = halfedge.getStartpoint();
            p2 = halfedge.getEndpoint();
            area += p1.x * p2.y;
            area -= p1.y * p2.x;
        }
        area /= 2;
        return area;
    }

    function cellCentroid(cell) {
        var x = 0,
            y = 0,
            halfedges = cell.halfedges,
            iHalfedge = halfedges.length,
            halfedge,
            v, p1, p2;
        while (iHalfedge--) {
            halfedge = halfedges[iHalfedge];
            p1 = halfedge.getStartpoint();
            p2 = halfedge.getEndpoint();
            v = p1.x * p2.y - p2.x * p1.y;
            x += (p1.x + p2.x) * v;
            y += (p1.y + p2.y) * v;
        }
        v = cellArea(cell) * 6;
        return {
            x: x / v,
            y: y / v
        };
    }

    function compute(sites) {
        VoronoiDemo.sites = sites;
        VoronoiDemo.voronoi.recycle(VoronoiDemo.diagram);
        VoronoiDemo.diagram = VoronoiDemo.voronoi.compute(sites, VoronoiDemo.bbox);
        updateStats();
        render();
        // console.log("run")
    }

    function updateStats() {
        if (!VoronoiDemo.diagram) {
            return;
        }
        var e = document.getElementById('voronoiStats');
        if (!e) {
            return;
        }
        e.innerHTML = '(' + VoronoiDemo.diagram.cells.length + ' Voronoi cells computed from ' + VoronoiDemo.diagram
            .cells
            .length + ' Voronoi sites in ' + VoronoiDemo.diagram.execTime +
            ' ms &ndash; rendering <i>not</i> included)';
    }

    function render() {
        var ctx = VoronoiDemo.canvas.getContext('2d');
        // console.log("run")
        // console.log(ctx)
        // background
        ctx.globalAlpha = 1;
        ctx.beginPath();
        ctx.rect(0, 0, VoronoiDemo.canvas.width, VoronoiDemo.canvas.height);
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.strokeStyle = '#888';
        ctx.stroke();
        // voronoi
        if (!VoronoiDemo.diagram) {
            return;
        }

        // edges
        ctx.beginPath();
        ctx.strokeStyle = '#000';
        var edges = VoronoiDemo.diagram.edges,
            iEdge = edges.length,
            edge, v;
        while (iEdge--) {
            edge = edges[iEdge];
            v = edge.va;
            ctx.moveTo(v.x, v.y);
            v = edge.vb;
            ctx.lineTo(v.x, v.y);
        }
        ctx.stroke();
        // sites

        ctx.beginPath();
        var radius = 15;


        var sites = VoronoiDemo.sites,
            iSite = sites.length;
        var countNumber = 0;
        if (!colorAdded) {
            for (let i = 0; i < sites.length; i++) {
                var colorToPush = "#" + ((1 << 24) * Math.random() | 0).toString(16)
                colorArray.push(colorToPush);
            }
        }

        while (iSite--) {



            var vElemnt = sites[iSite];

            // console.log(vElemnt);
            // ctx.fillStyle = "#" + (vElemnt.x * vElemnt.y | 0).toString(16)
            ctx.fillStyle = colorArray[iSite];
            
            // console.log(countNumber)
            // console.log(colorArray);
            ctx.rect(vElemnt.x - 2 / 3, vElemnt.y - 2 / 3, 2, 2);
            ctx.arc(vElemnt.x - 2 / 3, vElemnt.y - 2 / 3, radius, 0, Math.PI * 2);
            ctx.fill();
            // ctx.closePath()
            ctx.beginPath();

        }
        colorAdded = true;
        // ctx.fill();
        // ctx.closePath()

    }

    function animate() {

        requestAnimationFrame(animate);

        render2();
        // render();
        texture.needsUpdate = true;
        stats.update();

    }

    function render2() {

        const time = Date.now() * 0.001;

        // pointsMesh.rotation.x = time * 0.25;
        // points.rotation.y = time * 0.25;

        renderer.render(scene, camera);

    }
</script>

</html>