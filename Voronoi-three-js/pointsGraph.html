<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - buffergeometry - particles</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>

    <div id="container"></div>
    <div id="info"><a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - buffergeometry -
        particles</div>

    <script type="module">
        import * as THREE from '../three.js/build/three.module.js';

        import {
            Delaunay
        } from "https://cdn.skypack.dev/d3-delaunay@6";
        import Stats from '../three.js/examples/jsm/libs/stats.module.js';

        let container, stats;

        let camera, scene, renderer;

        let pointsMesh;

        init();
        animate();

        function init() {

            container = document.getElementById('container');

            //

            camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 5, 3500);
            camera.position.z = 275;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.Fog(0x050505, 2000, 3500);

            //

            const particles = 500000;

            const geometry = new THREE.BufferGeometry();

            const positions = [];
            const colors = [];
            const vertices = [];

            const color = new THREE.Color();

            const n = 1000,
                n2 = n / 2; // particles spread in the cube

            // for ( let i = 0; i < particles; i ++ ) {

            // 	// positions

            // 	const x = Math.random() * n - n2;
            // 	const y = Math.random() * n - n2;
            // 	const z = 0;

            // 	positions.push( x, y, z );

            // 	// colors

            // 	const vx = ( x / n ) + 0.5;
            // 	const vy = ( y / n ) + 0.5;
            // 	const vz = ( z / n ) + 0.5;

            // 	color.setRGB( vx, vy, vz );

            // 	colors.push( color.r, color.g, color.b );

            // }

            var array2D = [];
            const pictureWidth = 200;
            const pictureHeight = 200;


            for (let i = 0; i < pictureWidth; i++) {
                var tempArray = [];
                for (let j = 0; j < pictureHeight; j++) {
                    var objectToPush;
                    objectToPush = 0
                    tempArray.push(objectToPush)
                }
                array2D.push(tempArray)
            }

            console.log(array2D)





            var points = [];
            for (let i = 0; i < 30000; i++) {
                var element = [Math.random() * -50 + 25, Math.random() * -50 + 25];
                points.push(element);
            }
            console.log(Delaunay)
            const delaunay = Delaunay.from(points);
            const voronoi = delaunay.voronoi([0, 0, 50, 50]);

            var triangles = delaunay.triangles;

            for (let i = 0; i < triangles.length; i++) {
                // const pointElement = points[i];
                var t0 = triangles[i];
                vertices.push(points[t0][0], points[t0][1], 0);
                // normals.push(0, 0, 1);
                const r = Math.random();
                const g = Math.random();
                const b = Math.random();

                // colors.push(r, g, b);
                color.setRGB(r, g, b);
                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            geometry.computeBoundingSphere();

            //

            const material = new THREE.PointsMaterial({
                size: 1,
                vertexColors: true
            });

            pointsMesh = new THREE.Points(geometry, material);
            scene.add(pointsMesh);

            //













            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);

            container.appendChild(renderer.domElement);

            //

            stats = new Stats();
            container.appendChild(stats.dom);

            //

            window.addEventListener('resize', onWindowResize);

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        //

        function animate() {

            requestAnimationFrame(animate);

            render();
            stats.update();

        }

        function render() {

            const time = Date.now() * 0.001;

            pointsMesh.rotation.x = time * 0.25;
            // points.rotation.y = time * 0.25;

            renderer.render(scene, camera);

        }
    </script>

</body>

</html>